// from: https://github.com/facebook/jest/blob/master/integration_tests/utils.js

import { spawnSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

const mkdirp = require('mkdirp');
const rimraf = require('rimraf');

const run = (cmd: string, cwd?: string): any => {
    const args = cmd.split(/\s/).slice(1);
    const spawnOptions = { cwd };
    const result = spawnSync(cmd.split(/\s/)[0], args, spawnOptions);

    if (result.status !== 0) {
        const message = `
        ORIGINAL CMD: ${cmd}
        STDOUT: ${result.stdout && result.stdout.toString()}
        STDERR: ${result.stderr && result.stderr.toString()}
        STATUS: ${result.status}
        ERROR: ${result.error && result.error.toString()}
    `;
        throw new Error(message);
    }

    result.stdout = result.stdout && result.stdout.toString() as any;
    result.stderr = result.stderr && result.stderr.toString() as any;

    return result;
};

const linkJestPackage = (packageName: string, cwd: string) => {
    const packagesDir = path.resolve(__dirname, '../packages');
    const packagePath = path.resolve(packagesDir, packageName);
    const destination = path.resolve(cwd, 'node_modules/');
    run(`mkdir -p ${destination}`);
    return run(`ln -sf ${packagePath} ${destination}`);
};

const fileExists = (filePath: string) => {
    try {
        fs.accessSync(filePath, (fs as any).F_OK);
        return true;
    } catch (e) {
        return false;
    }
};

const makeTemplate = (str: string): ((values?: Array<any>) => string) => {
    return (values?: Array<any>) => {
        return str.replace(/\$(\d+)/g, (match, n) => {
            if (!Array.isArray(values)) {
                throw new Error('Array of values must be passed to the template.');
            }
            return values[n - 1];
        });
    };
};

const cleanup = (directory: string) => rimraf.sync(directory);

const writeFiles = (directory: string, files: { [filename: string]: string }) => {
    mkdirp.sync(directory);
    Object.keys(files).forEach(fileOrPath => {
        const filePath = fileOrPath.split(path.sep);
        const filename = filePath.pop();

        if (filePath.length) {
            mkdirp.sync(path.join.apply(path, [directory].concat(filePath)));
        }
        fs.writeFileSync(
            path.resolve.apply(path, [directory].concat(filePath, [filename as string])),
            files[fileOrPath],
        );
    });
};

const copyDir = (src: string, dest: string) => {
    const srcStat = fs.lstatSync(src);
    if (srcStat.isDirectory()) {
        if (!fs.existsSync(dest)) {
            fs.mkdirSync(dest);
        }
        fs.readdirSync(src).map(filePath => {
            return copyDir(path.join(src, filePath), path.join(dest, filePath));
        });
    } else {
        fs.writeFileSync(dest, fs.readFileSync(src));
    }
};

const createEmptyPackage = (
    directory: string,
    packageJson?: { [keys: string]: any },
) => {
    const DEFAULT_PACKAGE_JSON = {
        description: 'THIS IS AN AUTOGENERATED FILE AND SHOULD NOT BE ADDED TO GIT',
        jest: {
            testEnvironment: 'node',
        },
    };

    mkdirp.sync(directory);

    if (!packageJson) {
        packageJson = DEFAULT_PACKAGE_JSON;
    }

    fs.writeFileSync(
        path.resolve(directory, 'package.json'),
        JSON.stringify(packageJson, null, 2),
    );
};

const extractSummary = (stdout: string) => {
    const match = stdout.match(
        /Test Suites:.*\nTests.*\nSnapshots.*\nTime.*(\nRan all test suites)*.*\n*$/gm,
    );
    if (!match) {
        throw new Error(
            `
      Could not find test summary in the output.
      OUTPUT:
        ${stdout}
    `,
        );
    }

    const summary = match[0]
        .replace(/\d*\.?\d+m?s/g, '<<REPLACED>>')
        .replace(/, estimated <<REPLACED>>/g, '');

    const rest = cleanupStackTrace(
        stdout.slice(0, -match[0].length).replace(/\s*\(.*ms\)/gm, ''),
    );

    return { rest, summary };
};

const cleanupStackTrace = (output: string) => {
    return output
        .replace(/\n.*at.*timers\.js.*$/gm, '')
        .replace(/\n.*at.*assert\.js.*$/gm, '')
        .replace(/\n.*at.*node\.js.*$/gm, '')
        .replace(/\n.*at.*next_tick\.js.*$/gm, '')
        .replace(/\n.*at Promise \(<anonymous>\).*$/gm, '')
        .replace(/\n.*at <anonymous>.*$/gm, '')
        .replace(/\n.*at Generator.next \(<anonymous>\).*$/gm, '')
        .replace(/^.*at.*[\s][\(]?(\S*\:\d*\:\d*).*$/gm, '      at $1');
};

export {
    cleanup,
    cleanupStackTrace,
    copyDir,
    createEmptyPackage,
    extractSummary,
    fileExists,
    linkJestPackage,
    makeTemplate,
    run,
    writeFiles,
};